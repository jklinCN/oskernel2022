# 进程管理
## 进程管理数据结构
### 进程标识符与进程标识符分配器
进程标识符是一个互不相同的整数，用于唯一标识一个进程，这里我们使用 RAII（Resource Acquire Is Initialization） 的思想，将其抽象为一个 PidHandle 类型，当它的生命周期结束后对应的整数会被编译器自动回收。
```rust
pub struct PidHandle(pub usize);
```

为管理进程标识符的分配，保证进程标识符的唯一性，我们用类似之前的物理页帧分配器 `FrameAllocator` 的设计思想，实现了一个同样使用简单栈式分配策略的进程标识符分配器 `PidAllocator` ，并将其全局实例化为 `PID_ALLOCATOR`。
```rust
struct PidAllocator {
    current: usize,
    recycled: Vec<usize>,
}

impl PidAllocator {
    pub fn new() -> Self {
        PidAllocator {
            current: 0,
            recycled: Vec::new(),
        }
    }
    pub fn alloc(&mut self) -> PidHandle {
        if let Some(pid) = self.recycled.pop() {
            PidHandle(pid)
        } else {
            self.current += 1;
            PidHandle(self.current - 1)
        }
    }
    pub fn dealloc(&mut self, pid: usize) {
        assert!(pid < self.current);
        assert!(
            !self.recycled.iter().any(|ppid| *ppid == pid),
            "pid {} has been deallocated!", pid
        );
        self.recycled.push(pid);
    }
}
impl Drop for PidHandle {
    fn drop(&mut self) {
        PID_ALLOCATOR.exclusive_access().dealloc(self.0);
    }
}
```
`PidAllocator::alloc` 将会分配出去一个将 usize 包装之后的 `PidHandle` 。我们将其包装为一个全局分配进程标识符的接口 `pid_alloc` 提供给内核的其他子模块.同时我们也为 `PidHandle` 实现 Drop Trait 来允许编译器进行自动的资源回收。

在内存管理中的内核地址空间设计概览中我们介绍过内核地址空间布局 ，我们将每个应用的内核栈按照进程标识符从小到大的顺序将它们作为逻辑段从高地址到低地址放在内核地址空间中，且两两之间保留一个守护页面使得我们能够尽可能早的发现内核栈溢出问题。以下代码为内核栈的实现：
```rust
pub struct KernelStack {
    pid: usize,
}
impl KernelStack {
    #[allow(unused)]
    pub fn push_on_top<T>(&self, value: T) -> *mut T
    where
        T: Sized,
    {
        let kernel_stack_top = self.get_top();
        let ptr_mut = (kernel_stack_top - core::mem::size_of::<T>()) as *mut T;
        unsafe {
            *ptr_mut = value;
        }
        ptr_mut
    }
    pub fn get_top(&self) -> usize {
        let (_, kernel_stack_top) = kernel_stack_position(self.0);
        kernel_stack_top
    }
    impl Drop for KernelStack {
        fn drop(&mut self) {
            let (kernel_stack_bottom, _) = kernel_stack_position(self.pid);
            let kernel_stack_bottom_va: VirtAddr = kernel_stack_bottom.into();
            KERNEL_SPACE
                .exclusive_access()
                .remove_area_with_start_vpn(kernel_stack_bottom_va.into());
        }
    }
}
``` 
`KernelStack::push_on_top` 函数可以将一个类型为 T 的变量压入内核栈顶并返回其裸指针，这也是一个泛型函数。它在实现的时候用到了`KernelStack::get_top` 方法来获取当前内核栈顶在内核地址空间中的地址。内核栈 `KernelStack` 也用到了 RAII 的思想，具体来说，实际保存它的物理页帧的生命周期与它绑定在一起，当 KernelStack 生命周期结束后，这些物理页帧也将会被编译器自动回收。这仅需要为 `KernelStack` 实现 Drop Trait，一旦它的生命周期结束则在内核地址空间中将对应的逻辑段删除。

### 进程控制块
在内核中，每个进程的执行状态、资源控制等元数据均保存在进程控制块结构中，它是内核对进程进行管理的单位，在内核看来，它就等价于一个进程。
```rust
pub struct TaskControlBlock {
    pub pid: PidHandle,
    pub tgid: usize,
    pub kernel_stack: KernelStack,
    inner: UPSafeCell<TaskControlBlockInner>,
}
pub struct TaskControlBlockInner {
    // 进程
    pub trap_cx_ppn: PhysPageNum,
    pub task_cx: TaskContext,
    pub task_status: TaskStatus,
    pub parent: Option<Weak<TaskControlBlock>>, 
    pub children: Vec<Arc<TaskControlBlock>>,
    pub exit_code: i32,  

    // 内存
    pub base_size: usize,
    pub memory_set: MemorySet,
    pub mmap_area: MmapArea,
    pub heap_start: usize,
    pub heap_pt: usize,
    
    // 文件
    pub fd_table: Vec<Option<Arc<dyn File + Send + Sync>>>,

    // 状态信息
    pub signals: SignalFlags,
    pub current_path: String,
}
```
任务控制块中包含两部分：
- 在初始化之后就不再变化的元数据：直接放在任务控制块中。这里将 `pid` 、`tgid` 和内核栈 `KernelStack` 放在其中；
- 在运行过程中可能发生变化的元数据：则放在 `TaskControlBlockInner` 中，将它再包裹上一层 `UPSafeCell<T>` 放在任务控制块中。这是因为在我们的设计中外层只能获取任务控制块的不可变引用，若想修改里面的部分内容的话这需要 `UPSafeCell<T>` 所提供的内部可变性。

`TaskControlBlockInner` 中则包含下面这些内容：
- `trap_cx_ppn` 指出了应用地址空间中的 Trap 上下文，被放在的物理页帧的物理页号。
- `task_cx` 将暂停的任务的任务上下文保存在任务控制块中。
- `task_status` 维护当前进程的执行状态。
- `parent` 指向当前进程的父进程（如果存在的话）。注意我们使用 Weak 而非 Arc 来包裹另一个任务控制块，因此这个智能指针将不会影响父进程的引用计数。
- `children` 则将当前进程的所有子进程的任务控制块以 Arc 智能指针的形式保存在一个向量中，这样才能够更方便的找到它们。
- `exit_code` 当进程调用 exit 系统调用主动退出或者执行出错由内核终止的时候，它的退出码 exit_code 会被内核保存在它的任务控制块中，并等待它的父进程通过 waitpid 回收它的资源的同时也收集它的 PID 以及退出码。
- `base_size` 的含义是：应用数据仅有可能出现在应用地址空间低于 base_size 字节的区域中。借助它我们可以清楚的知道应用有多少数据驻留在内存中。
- `memory_set` 表示应用地址空间。
- `mmap_area` 表示mmap内存空间信息的结构体
- `heap_start` 表示堆空间起始虚拟地址
- `heap_pt` 表示堆空间当前堆顶虚拟地址

任务控制块 TaskControlBlock 目前提供以下方法
```rust
impl TaskControlBlock {
    pub fn inner_exclusive_access(&self) -> RefMut<'_, TaskControlBlockInner> {
        self.inner.exclusive_access()
    }
    pub fn getpid(&self) -> usize { self.pid.0 }
    pub fn new(elf_data: &[u8]) -> Self {...}
    pub fn exec(&self, elf_data: &[u8]) {...}
    pub fn fork(self: &Arc<TaskControlBlock>) -> Arc<TaskControlBlock> {...}
    pub fn mmap(&self, start: usize, len: usize, prot: usize, flags: usize, fd: isize, off: usize) -> usize { ... }
    pub fn munmap(&self, start: usize, len: usize) -> isize { ... }
    pub fn check_lazy(&self, va: VirtAddr, is_load: bool) -> isize { ... }
    pub fn lazy_mmap(&self, va: VirtAddr, is_load: bool) -> isize { ... }
}
```
- `inner_exclusive_access` 通过 `UPSafeCell<T>.exclusive_access()` 来得到一个 `RefMut<'_, TaskControlBlockInner>` ，它可以被看成一个内层 `TaskControlBlockInner` 的可变引用并可以对它指向的内容进行修改。
- `getpid` 以 usize 的形式返回当前进程的进程标识符。
- `new` 用来创建一个新的进程，目前仅用于内核中手动创建唯一一个初始进程 initproc 。
- `exec` 用来实现 exec 系统调用，即当前进程加载并执行另一个 ELF 格式可执行文件。
- `fork` 用来实现 fork 系统调用，即当前进程 fork 出来一个与之几乎相同的子进程。
- `mmap` 用来在进程虚拟地址空间中分配创建一片虚拟内存地址映射
- `munmap` 用来在进程虚拟地址空间中删除一片虚拟内存地址映射
- `lazy_mmap` 用来在mmap缺页时使用lzay加载机制加载一片虚拟内存地址映射

### 任务管理器
```rust
pub struct TaskManager {
    ready_queue: VecDeque<Arc<TaskControlBlock>>,
}

impl TaskManager {
    pub fn new() -> Self {
        Self {
            ready_queue: VecDeque::new(),
        }
    }
    pub fn add(&mut self, task: Arc<TaskControlBlock>) {
        self.ready_queue.push_back(task);
    }
    pub fn fetch(&mut self) -> Option<Arc<TaskControlBlock>> {
        self.ready_queue.pop_front()
    }
}

lazy_static! {
    pub static ref TASK_MANAGER: UPSafeCell<TaskManager> =
        unsafe { UPSafeCell::new(TaskManager::new()) };
}
pub fn add_task(task: Arc<TaskControlBlock>) {
    PID2TCB
        .exclusive_access()
        .insert(task.getpid(), Arc::clone(&task));
    TASK_MANAGER.exclusive_access().add(task);
}
pub fn fetch_task() -> Option<Arc<TaskControlBlock>> {
    TASK_MANAGER.exclusive_access().fetch()
}
```
`TaskManager` 将所有的任务控制块用引用计数 `Arc` 智能指针包裹后放在一个双端队列 `VecDeque` 中。正如之前介绍的那样，我们并不直接将任务控制块放到 `TaskManager` 里面，而是将它们放在内核堆上，在任务管理器中仅存放他们的引用计数智能指针，这也是任务管理器的操作单位。这样做的原因在于，任务控制块经常需要被放入/取出，如果直接移动任务控制块自身将会带来大量的数据拷贝开销，而对于智能指针进行移动则没有多少开销。其次，允许任务控制块的共享引用在某些情况下能够让我们的实现更加方便。

`TaskManager` 提供 `add`/`fetch` 两个操作，前者表示将一个任务加入队尾，后者则表示从队头中取出一个任务来执行。从调度算法来看，这里用到的就是最简单的 RR 算法。全局实例 `TASK_MANAGER` 则提供给内核的其他子模块 `add_task`/`fetch_task` 两个函数。

### 处理器管理结构
处理器管理结构用于维护CPU状态信息，我们为每一个核心创建了一个全局实例，以下为处理器管理结构体代码：
```rust
pub struct Processor {  
    current: Option<Arc<TaskControlBlock>>, // 当前处理器上正在执行的任务
    idle_task_cx: TaskContext,  // 当前处理器上的 idle 控制流的任务上下文
}
impl Processor {
    /// 取出CPU当前正在执行的任务
    pub fn take_current(&mut self) -> Option<Arc<TaskControlBlock>> {
        self.current.take()
    }
    /// 返回CPU当前执行的任务的一份拷贝
    pub fn current(&self) -> Option<Arc<TaskControlBlock>> {
        self.current.as_ref().map(Arc::clone)
    }
}
/// 从全局变量 `PROCESSOR` 中取出当前正在执行的任务
pub fn take_current_task() -> Option<Arc<TaskControlBlock>> {
    PROCESSOR.exclusive_access().take_current()
}
/// 从全局变量 `PROCESSOR` 中取出当前正在执行任务的任务控制块的引用计数的一份拷贝
pub fn current_task() -> Option<Arc<TaskControlBlock>> {
    PROCESSOR.exclusive_access().current()
}
/// 从全局变量 `PROCESSOR` 中取出当前正在执行任务的用户地址空间 token
pub fn current_user_token() -> usize {
    let task = current_task().unwrap();
    let token = task.inner_exclusive_access().get_user_token();
    token
}
pub fn current_trap_cx() -> &'static mut TrapContext {
    current_task().unwrap().inner_exclusive_access().get_trap_cx()
}
```
在抢占式调度模型中，在一个处理器上执行的任务常常被换入或换出，因此我们提供了相关的接口用于获取处理器正在执行的任务信息。

## 进程管理机制
### 初始进程的创建
内核初始化完毕之后即会调用 `task` 子模块提供的 `add_initproc` 函数来将初始进程 `initproc` 加入任务管理器，但在这之前我们需要初始化初始进程的进程控制块 `INITPROC` ，这个过程基于 `lazy_static` 在运行时完成。
```rust
lazy_static! {
    pub static ref INITPROC: Arc<TaskControlBlock> = Arc::new({
        extern "C" {
            fn _num_app();
        }
        let num_app_ptr = _num_app as usize as *const usize;
        let num_app = unsafe { num_app_ptr.read_volatile() }; 
        let app_start = unsafe { core::slice::from_raw_parts(num_app_ptr.add(1), num_app + 1) };
        TaskControlBlock::new( unsafe{
            core::slice::from_raw_parts(
                app_start[0] as *const u8, 
                app_start[1] - app_start[0]
            ) } 
        )
    });
}
pub fn add_initproc() {
    add_task(INITPROC.clone());
}
```
我们调用 `TaskControlBlock::new` 来创建一个进程控制块，它需要传入 ELF 可执行文件的数据切片作为参数，我们已经将初始进程代码通过内联汇编固定在内核数据内，这个初始程序会依次运行全部测试程序，只需通过全局符号 `_num_app` 确定数据区起始地址后按数据切片的格式读取即可。在初始化 INITPROC 之后，就可以在 add_initproc 中调用 task 的任务管理器 manager 子模块提供的 add_task 接口，将其加入到任务管理器。

### 进程调度机制
通过调用 `task` 子模块提供的 `suspend_current_and_run_next` 函数可以暂停当前任务并切换到下一个任务，当应用调用 `sys_yield` 主动交出使用权、本轮时间片用尽或者由于某些原因内核中的处理无法继续的时候，就会在内核中调用此函数触发调度机制并进行任务切换。以下代码为这两种情况的代码实现：
```rust
// os/src/syscall/process.rs

pub fn sys_yield() -> isize {
    suspend_current_and_run_next();
    0
}

// os/src/trap/mod.rs

#[no_mangle]
pub fn trap_handler() -> ! {
    set_kernel_trap_entry();
    let scause = scause::read();
    let stval = stval::read();
    match scause.cause() {
        Trap::Interrupt(Interrupt::SupervisorTimer) => {
            set_next_trigger();
            suspend_current_and_run_next();
        }
        ...
    }
    trap_return();
}
```
以下代码为 `suspend_current_and_run_next` 函数的具体实现：
```rust
pub fn suspend_current_and_run_next() {
    // 取出当前正在执行的任务
    let task = take_current_task().unwrap();
    let mut task_inner = task.inner_exclusive_access();
    let task_cx_ptr = &mut task_inner.task_cx as *mut TaskContext;
    // 修改其进程控制块内的状态为就绪状态
    task_inner.task_status = TaskStatus::Ready;
    drop(task_inner);
    // 将进程加入进程管理器中的就绪队列
    add_task(task);
    // 开启一轮新的调度
    schedule(task_cx_ptr);
}
```
首先通过 `take_current_task` 来取出当前正在执行的任务，修改其进程控制块内的状态，随后将这个任务放入任务管理器的队尾。接着调用 `schedule` 函数来触发调度并切换任务。

### 进程的生成机制
在内核中手动生成的进程只有初始进程 `initproc` ，余下所有的进程都是它直接或间接 `fork` 出来的。当一个子进程被 `fork` 出来之后，它可以调用 `exec` 系统调用来加载并执行另一个可执行文件。
以下代码为 fork 的实现
```rust
pub fn fork(self: &Arc<TaskControlBlock>, is_create_thread: bool) -> Arc<TaskControlBlock> {
    let mut parent_inner = self.inner_exclusive_access();
    // 拷贝用户地址空间
    let memory_set = MemorySet::from_existed_user(&parent_inner.memory_set);
    let trap_cx_ppn = memory_set
        .translate(VirtAddr::from(TRAP_CONTEXT).into())
        .unwrap()
        .ppn();
    let pid_handle = pid_alloc();   // 分配一个 PID
    let mut tgid = 0;
    if is_create_thread{
        tgid = self.pid.0;
    }
    else{
        tgid = pid_handle.0;
    }
    // 根据 PID 创建一个应用内核栈
    let kernel_stack = KernelStack::new(&pid_handle);
    let kernel_stack_top = kernel_stack.get_top();

    let mut new_fd_table: Vec<Option<Arc<dyn File + Send + Sync>>> = Vec::new();
    for fd in parent_inner.fd_table.iter() {
        if let Some(file) = fd {
            new_fd_table.push(Some(file.clone()));
        } else {
            new_fd_table.push(None);
        }
    }

    let task_control_block = Arc::new(TaskControlBlock {
        pid: pid_handle,
        tgid,
        kernel_stack,
        inner: unsafe {
            UPSafeCell::new(TaskControlBlockInner {
                trap_cx_ppn,
                base_size: parent_inner.base_size,
                heap_start: parent_inner.heap_start,
                heap_pt: parent_inner.heap_pt,
                task_cx: TaskContext::goto_trap_return(kernel_stack_top),
                task_status: TaskStatus::Ready,
                memory_set,
                parent: Some(Arc::downgrade(self)),
                children: Vec::new(),
                exit_code: 0,
                fd_table: new_fd_table,
                signals: SignalFlags::empty(),
                current_path: parent_inner.current_path.clone(),
                mmap_area: MmapArea::new(VirtAddr::from(MMAP_BASE), VirtAddr::from(MMAP_BASE)),
            })
        },
    });
    // 把新生成的进程加入到子进程向量中
    parent_inner.children.push(task_control_block.clone());
    // 更新子进程 trap 上下文中的栈顶指针
    let trap_cx = task_control_block.inner_exclusive_access().get_trap_cx();
    trap_cx.kernel_sp = kernel_stack_top;

    task_control_block
}
```
实现fork首先调用 `MemorySet::from_existed_user` 函数将父进程的地址空间拷贝一份作为子进程的用户地址空间，然后调用 `pid_alloc` 函数获取一个PID根据PID创建应用内核栈，紧接着复制父进程的文件描述符表、创建进程控制块，最后把新生成的进程加入到子进程向量中函数返回子进程的进程控制块。
以下代码为 exec 的实现
```rust
pub fn exec(&self, elf_data: &[u8], args: Vec<String>) {
    // 从 ELF 文件生成一个全新的地址空间并直接替换
    let (memory_set, mut user_sp,user_heap, entry_point) = MemorySet::from_elf(elf_data);
    let trap_cx_ppn = memory_set
        .translate(VirtAddr::from(TRAP_CONTEXT).into())
        .unwrap()
        .ppn();

    user_sp -= (args.len() + 1) * core::mem::size_of::<usize>();
    let argv_base = user_sp;                // 参数字符串首地址数组 起始地址
    let mut argv: Vec<_> = (0..=args.len()) // 获取 参数字符串首地址数组 在用户栈中的可变引用
        .map(|arg| {
            translated_refmut(
                memory_set.token(),
                (argv_base + arg * core::mem::size_of::<usize>()) as *mut usize,
            )
        })
        .collect();

    // 参数字符串
    *argv[args.len()] = 0;  // 标记参数尾
    for i in 0..args.len() {
        user_sp -= args[i].len() + 1;   // 在用户栈中分配 参数i 的空间
        *argv[i] = user_sp;             // 在 参数字符串首地址数组中 记录 参数i 首地址
        let mut p = user_sp;
        for c in args[i].as_bytes() {   // 将参数写入到用户栈
            *translated_refmut(memory_set.token(), p as *mut u8) = *c;
            p += 1;
        }                               // 写入字符串结束标记
        *translated_refmut(memory_set.token(), p as *mut u8) = 0;
    }

    user_sp -= user_sp % core::mem::size_of::<usize>();

    let mut inner = self.inner_exclusive_access();
    inner.memory_set = memory_set;  // 这将导致原有的地址空间生命周期结束，里面包含的全部物理页帧都会被回收
    inner.heap_start = user_heap;
    inner.heap_pt = user_heap;
    inner.trap_cx_ppn = trap_cx_ppn;
    let trap_cx = inner.get_trap_cx();
    // 修改新的地址空间中的 Trap 上下文，将解析得到的应用入口点、用户栈位置以及一些内核的信息进行初始化
    *trap_cx = TrapContext::app_init_context(
        entry_point,
        user_sp,
        KERNEL_SPACE.exclusive_access().token(),
        self.kernel_stack.get_top(),
        trap_handler as usize,
    );
    // 修改 Trap 上下文中的 a0/a1 寄存器
    trap_cx.x[10] = args.len(); // a0 表示命令行参数的个数
    trap_cx.x[11] = argv_base;  // a1 则表示 参数字符串首地址数组 的起始地址
}
```
exec 系统调用使得一个进程能够加载一个新应用的 ELF 可执行文件中的代码和数据替换原有的应用地址空间中的内容，并开始执行。系统调用分发函数会根据系统调用号将 exec 系统调用交由 `TaskControlBlock::exec` 函数执行。该函数首先从 ELF 文件生成一个全新的地址空间并直接替换进来，这将导致原有的地址空间生命周期结束，里面包含的全部物理页帧都会被回收；然后修改新的地址空间中的 Trap 上下文，将解析得到的应用入口点、用户栈位置以及一些内核的信息进行初始化，这样才能正常实现 Trap 机制。

### 进程的退出机制及资源回收
当应用调用 sys_exit 系统调用主动退出或者出错由内核终止之后，会在内核中调用 exit_current_and_run_next 函数退出当前进程并切换到下一个进程。
```rust
pub fn exit_current_and_run_next(exit_code: i32) {
    // 获取访问权限，修改进程状态
    let task = take_current_task().unwrap();
    remove_from_pid2task(task.getpid());
    let mut inner = task.inner_exclusive_access();
    inner.task_status = TaskStatus::Zombie; // 后续才能被父进程在 waitpid 系统调用的时候回收
    // 记录退出码，后续父进程在 waitpid 的时候可以收集
    inner.exit_code = exit_code;
    {   // 将这个进程的子进程转移到 initproc 进程的子进程中
        let mut initproc_inner = INITPROC.inner_exclusive_access();
        for child in inner.children.iter() {
            child.inner_exclusive_access().parent = Some(Arc::downgrade(&INITPROC));
            initproc_inner.children.push(child.clone());    // 引用计数 -1
        }
    }
    inner.children.clear(); // 引用计数 +1
    // 对于当前进程占用的资源进行早期回收
    inner.memory_set.recycle_data_pages();
    drop(inner);
    drop(task);
    // 使用全0的上下文填充换出上下文，开启新一轮进程调度
    let mut _unused = TaskContext::zero_init();
    schedule(&mut _unused as *mut _);
}
```
我们调用 `take_current_task` 来将当前进程控制块从处理器监控 `PROCESSOR` 中取出一份拷贝，这是为了正确维护进程控制块的引用计数；我们将进程控制块中的状态修改为 `TaskStatus::Zombie` 即僵尸进程，这样它后续才能被父进程在 `waitpid` 系统调用的时候回收；我们将传入的退出码 `exit_code` 写入进程控制块中，后续父进程在 `waitpid` 的时候可以收集；`MemorySet::recycle_data_pages` 只是将地址空间中的逻辑段列表 `areas` 清空（即执行 `Vec` 向量清空），这将导致应用地址空间被回收（即进程的数据和代码对应的物理页帧都被回收），但用来存放页表的那些物理页帧此时还不会被回收（会由父进程最后回收子进程剩余的占用资源）。最后我们调用 schedule 触发调度及任务切换。

父进程通过 sys_waitpid 系统调用来回收子进程的资源并收集它的一些信息：
```rust
pub fn sys_waitpid(pid: isize, exit_code_ptr: *mut i32) -> isize {
    let task = current_task().unwrap();
    let inner = task.inner_exclusive_access();

    // 根据pid参数查找有没有符合要求的进程
    if !inner.children.iter()
        .any(|p| pid == -1 || pid as usize == p.getpid()) {
        return -1;
    }
    drop(inner);
    loop{
        let mut inner = task.inner_exclusive_access();
        // 查找所有符合PID要求的处于僵尸状态的进程，如果有的话还需要同时找出它在当前进程控制块子进程向量中的下标
        let pair = inner.children.iter().enumerate().find(|(_, p)| {
            p.inner_exclusive_access().is_zombie() && (pid == -1 || pid as usize == p.getpid())
        });
        if let Some((idx, _)) = pair {
            // 将子进程从向量中移除并置于当前上下文中
            let child = inner.children.remove(idx);
            assert_eq!(Arc::strong_count(&child), 1);
            // 收集的子进程信息返回
            let found_pid = child.getpid();
            let exit_code = child.inner_exclusive_access().exit_code;
            // 将子进程的退出码写入到当前进程的应用地址空间中
            if exit_code_ptr as usize != 0 {
                *translated_refmut(inner.memory_set.token(), exit_code_ptr) = exit_code << 8;
            }
            return found_pid as isize;
        } else {
            // 如果找不到的话则放权等待
            drop(inner);
            suspend_current_and_run_next();
        }
    }
}
```