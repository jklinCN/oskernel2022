#### 问题与解决

此部分在 `RongOS设计与实现文档.pdf` 的决赛第一阶段中。

#### 不足与待完善

1. 有非常多的系统调用需要完善（尤其是文件系统），详情可以参见 syscall/mod.rs 与 syscall/fs.rs

2. 有部分测试用例（sscanf_eof、tgmath等14个静态测试程序）在板卡（包括评测机）上可以通过，但在qemu虚拟机上却发生了以下错误，目前并没有弄清这一情况

   ```
   [kernel] Illegal Instruction, SIGILL=4
   ```

3. simple-fat32 中 VFile 的 read_at 存在内存泄漏情况，这是在 fs/inode.rs 中添加以下代码发现的，并且这个问题关联着以下几个问题。

   ```rust
   pub fn read_all(&self) -> Vec<u8> {
       ...
       loop {
           heap_allocator_stats();
           println!("read at");
           let len = inner.inode.read_at(inner.offset, &mut buffer);
           heap_allocator_stats();
       ...
   }
       
   /// 输出结果如下：
   /// heap usage: 24.94%
   /// read at
   /// heap usage: 24.97%
   ```

4. 内存分配的不足：RongOS沿袭了 rcore 的做法，堆空间使用外部库进行管理，直至目前采用的都是 buddy_system_allocator，但实际看下来它不能很好满足小内存的需要。因此堆空间分配这里需要做提升与优化（毕竟我们享受了 alloc 库所带来的便捷，换句话说离不开 Vec 类型了）

5. RongOS 对于 ELF 文件的处理，目前只停留在完整读入ELF文件，当文件非常大时（比如决赛的entry-static.exe）这就要求堆空间足够大，且受限于 Vec 的扩容特性，在测试中我们需要 1M 的内存空间去存储这个ELF文件，且最终我们得为内核堆空间设置了 3M 内存才能正常运行内核与测试程序，这太浪费了。并且堆空间是设置在 bss 段中，这也导致了即便这段内存空间空闲时，用户进程也无法使用到这片空间。

6. 我们的 mmap 与 lazy 加载还有很多的问题，这也导致我们不能进行分段读入 ELF，甚至对 ELF 做全局 lazy，这与上述的问题是紧密相连的。并且这也导致了我们的动态链接器无法正确地运行，即便我们已经明白应如何做到动态加载。

#### 总结

1. 决赛给我带来了全方面的提升，一开始我连测试用例的 main 函数都进不去，通过无数次的 gdb 调试才一步一步通过了 musl 库的 init 过程，这段过程让我掌握了 gdb 调试的一些技巧，也极大程度地提高了我的调试能力（包括使用 objdump 后观察汇编代码）。
2. 在做初赛内容时我并没有感受到 rcore 带来的限制，然而在决赛时我在许多地方感受到了局限性，譬如上面提到的将 ELF 文件完整读入。由于 rcore 是教学用途的系统，因此并不涉及我们决赛的一些内容，所以我们在做决赛内容时受限于底层架构而束手束脚。没有决心修改底层架构，也没有能力去弥补决赛内容。